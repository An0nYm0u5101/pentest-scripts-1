#!/usr/bin/python3
# -*- coding: utf-8 -*-
import os
import re
import socket
import sys

# Colors
from argparse import Namespace

green = '\033[32m'
red = '\033[31m'
reset = '\033[0m'
yellow = '\033[33m'

banner = """
           ██████ ▓█████ ▓█████  ██ ▄█▀    ██▓    ▓█████ ▄▄▄       ██ ▄█▀
         ▒██    ▒ ▓█   ▀ ▓█   ▀  ██▄█▒    ▓██▒    ▓█   ▀▒████▄     ██▄█▒ 
         ░ ▓██▄   ▒███   ▒███   ▓███▄░    ▒██░    ▒███  ▒██  ▀█▄  ▓███▄░ 
           ▒   ██▒▒▓█  ▄ ▒▓█  ▄ ▓██ █▄    ▒██░    ▒▓█  ▄░██▄▄▄▄██ ▓██ █▄ 
         ▒██████▒▒░▒████▒░▒████▒▒██▒ █▄   ░██████▒░▒████▒▓█   ▓██▒▒██▒ █▄
         ▒ ▒▓▒ ▒ ░░░ ▒░ ░░░ ▒░ ░▒ ▒▒ ▓▒   ░ ▒░▓  ░░░ ▒░ ░▒▒   ▓▒█░▒ ▒▒ ▓▒
         ░ ░▒  ░ ░ ░ ░  ░ ░ ░  ░░ ░▒ ▒░   ░ ░ ▒  ░ ░ ░  ░ ▒   ▒▒ ░░ ░▒ ▒░
         ░  ░  ░     ░      ░   ░ ░░ ░      ░ ░      ░    ░   ▒   ░ ░░ ░ 
               ░     ░  ░   ░  ░░  ░          ░  ░   ░  ░     ░  ░░  ░   
"""

project = {
    'project': 'Seek Leak',
    'version': 'v0.0.1',
    'author': 'skate_forever',
    'labs' : 'iBLISSLabs'
}

try:
    sys.path.insert(0, os.path.abspath(os.path.join(os.path.join(os.path.dirname(__file__), ('./')))))
    from modules.arguments import *
    from modules.docker import Docker
    from modules.haveibeenpwned import HaveIBeenPwned
    from modules.local import Local
    from modules.pwndb import PwnDB
except ModuleNotFoundError as error:
    print("Error: ")
    print("    Verify the existence of the directory: ./modules/")
    print("    Please install the requirements: $ sudo -H pip3 install -r requirements.txt")
    sys.exit(1)

def main():
    print(banner)
    print("\t\t\t\t\t\t\t by "+ project['author'])
    print("\t\t\t\t\t\t\t and "+ project['labs']+"\n")
    args = Arguments().parser()
    docker = Docker()
    pwn = PwnDB()

    if args.beenpwned == True:
        beenpwned = HaveIBeenPwned()
        beenpwned.check_config("seek-leak.conf")

    if args.allbreaches == True and args.output is not None:
        beenpwned.breached_total(args.output.name)
    elif args.allbreaches == True:
        beenpwned.breached_total(None)

    if args.container == True:
        docker_start = docker.start()
        if pwn.check_proxy(docker.get_ip()+":8118"):
            proxy = docker.get_ip()+":8118"
    
    if args.proxy is not None and pwn.check_proxy(args.proxy) == True:
            proxy = args.proxy

    if args.input is not None:
        with open(args.input.name, "r") as leaks_file:
            regex_email = '^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$'
            leak = leaks_file.readline().strip()
            while leak:
                # e-mail
                if re.search(regex_email, leak.lower()):
                    print("Analyzing the "+leak+"...")
                    if Arguments().check_email(leak) == True:
                        if args.beenpwned == True and args.output is None:
                            email_leak = beenpwned.breached_account(leak, None)
                            paste_leak = beenpwned.breached_pastebin(leak, None)
                            if args.force == True and args.container:
                                pwn.get_leak(proxy, leak, None)
                            elif args.force == True and args.proxy:
                                pwn.get_leak(proxy, leak, None)
                            elif args.force == True and args.location:
                                pass
                        elif args.beenpwned == True and args.output is not None:
                            email_leak = beenpwned.breached_account(leak, args.output.name)
                            paste_leak = beenpwned.breached_pastebin(leak, args.output.name)
                            if args.force == True and args.container:
                                pwn.get_leak(proxy, leak, args.output.name)
                            elif args.force == True and args.proxy:
                                pwn.get_leak(proxy, leak, args.output.name)
                            elif args.force == True and args.location:
                                pass
                        elif proxy is not None and args.output is not None:
                            pwn.get_leak(proxy, leak, args.output.name)
                        elif proxy is not None:
                            pwn.get_leak(proxy, leak, None)
                else:
                    try:
                        # domain
                        if socket.gethostbyname(leak.lower()):
                            print("Analyzing the "+leak+"...")
                            if args.beenpwned == True and args.output is None:
                                domain_leak = beenpwned.breached_domain(leak, None)
                                if args.force == True and args.container:
                                    pwn.get_leak(proxy, leak, None)
                                elif args.force == True and args.proxy:
                                    pwn.get_leak(proxy, leak, None)
                                elif args.force == True and args.location:
                                    pass
                            elif args.beenpwned == True and args.output is not None:
                                domain_leak = beenpwned.breached_domain(leak, args.output.name)
                                if args.force == True and args.container:
                                    pwn.get_leak(proxy, leak, args.output.name)
                                elif args.force == True and args.proxy:
                                    pwn.get_leak(proxy, leak, args.output.name)
                                elif args.force == True and args.location:
                                    pass
                            elif args.domain is not None and args.output is not None:
                                pwn.get_leak(proxy, leak, args.output.name)
                            elif args.domain is not None:
                                pwn.get_leak(proxy, leak, None)
                    except socket.gaierror:
                        print("Analyzing the "+leak+"...")
                        if args.beenpwned == True and args.output is not None:
                            beenpwned.breached_pass(leak, args.output.name)
                            if args.force == True:
                                pwn.get_pass(proxy, leak, args.output.name)
                        elif args.beenpwned == True and args.output is None:
                            beenpwned.breached_pass(leak, None)
                            if args.force == True:
                                pwn.get_pass(proxy, leak, None)
                        elif args.output is not None:
                            pwn.get_pass(proxy, leak, args.output.name)
                        elif args.beenpwned == False:
                            pwn.get_pass(proxy, leak, None)
                leak = leaks_file.readline().strip()
    else:
        if args.domain is not None and Arguments().check_domain(args.domain) == True:
            if args.beenpwned == True and args.output is None:
                domain_leak = beenpwned.breached_domain(args.domain, None)
                if args.force == True and args.container:
                    pwn.get_leak(proxy, args.domain, None)
                elif args.force == True and args.proxy:
                    pwn.get_leak(proxy, args.domain, None)
                elif args.force == True and args.location:
                    pass
            elif args.beenpwned == True and args.output is not None:
                domain_leak = beenpwned.breached_domain(args.domain, args.output.name)
                if args.force == True and args.container:
                    pwn.get_leak(proxy, args.domain, args.output.name)
                elif args.force == True and args.proxy:
                    pwn.get_leak(proxy, args.domain, args.output.name)
                elif args.force == True and args.location:
                    pass
            elif args.domain is not None and args.output is not None:
                pwn.get_leak(proxy, args.domain, args.output.name)
            elif args.domain is not None:
                pwn.get_leak(proxy, args.domain, None)

        if args.email is not None and Arguments().check_email(args.email) == True:
            if args.beenpwned == True and args.output is None:
                email_leak = beenpwned.breached_account(args.email, None)
                paste_leak = beenpwned.breached_pastebin(args.email, None)
                if args.force == True and args.container:
                    pwn.get_leak(proxy, args.email, None)
                elif args.force == True and args.proxy:
                    pwn.get_leak(proxy, args.email, None)
                elif args.force == True and args.location:
                    pass
            elif args.beenpwned == True and args.output is not None:
                email_leak = beenpwned.breached_account(args.email, args.output.name)
                paste_leak = beenpwned.breached_pastebin(args.email, args.output.name)
                if args.force == True and args.container:
                    pwn.get_leak(proxy, args.email, args.output.name)
                elif args.force == True and args.proxy:
                    pwn.get_leak(proxy, args.email, args.output.name)
                elif args.force == True and args.location:
                    pass
            elif args.email is not None and args.output is not None:
                pwn.get_leak(proxy, args.email, args.output.name)
            elif args.email is not None:
                pwn.get_leak(proxy, args.email, None)

        if args.beenpwned == True and args.secret is not None and args.output is not None:
            beenpwned.breached_pass(args.secret, args.output.name)
            if args.force == True:
                pwn.get_pass(proxy, args.secret, args.output.name)
        elif args.beenpwned == True and args.secret is not None:
            beenpwned.breached_pass(args.secret, None)
            if args.force == True:
                pwn.get_pass(proxy, args.secret, None)
        elif args.secret is not None and args.output is not None:
            secret = args.secret
            pwn.get_pass(proxy, secret, args.output.name)
        elif args.secret is not None:
            secret = args.secret
            pwn.get_pass(proxy, secret, None)

    try:
        if docker_start == True:
            docker.stop()
    except UnboundLocalError:
        pass

if __name__ == "__main__":
    main()
