#!/usr/bin/python3
# -*- coding: utf-8 -*-
import os
import re
import requests
import sys
import time
from modules.docker import Docker

class PwnDB:

    def __init__(self):
        self.data = {
            'luseropr'  : 0,
            'domainopr' : 0,
            'submitform': 'em'
        }
        self.url = 'http://pwndb2am4tzkvold.onion/'
        self.url_regex = '^([a-z]|[A-Z]|[0-9]|\.|-|_|~|\[|\]|#|\'|\(|\)|;|:|@|&|=|\+|\$|,|\*|!|\/|\?)+$'
        self.headers = {
            'Host': 'pwndb2am4tzkvold.onion',
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:79.0) Gecko/20100101 Firefox/79.0',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Content-Type': 'application/x-www-form-urlencoded',
            'Content-Length': '69',
            'Origin': 'http://pwndb2am4tzkvold.onion',
            'Referer': 'http://pwndb2am4tzkvold.onion/',
        }
        self.regex = '^[\w\.\+\-\_]+\@[\w]+\.[a-z]{3,4}$'

        self.docker = Docker()

    # validating the proxy ip
    def proxy_parser(self, proxy):
        try:
            if re.search(r'^http.*\/\/|^socks.*\/\/', proxy.lower()):
                proxy = proxy.split('//')[1]
            self.proxy_ip = proxy.split(':')[0]
            self.proxy_port = proxy.split(':')[1]
        except:
            print("Failed!!!")
            print("Please, provide a valid address:port as proxy.")
            sys.exit(1)

        if self.proxy_port == "9040" or self.proxy_port == "9050":
            proxies_socks = {
                'http' : 'socks5h://%s' % proxy,
                'https' : 'socks5h://%s' % proxy,
            }
            return proxies_socks
        else: 
            proxies_http = {
                'http' : 'http://%s' % proxy,
                'https' : 'http://%s' % proxy,
            }
            return proxies_http

    # checking the onion network
    def check_proxy(self, proxy):
        print("Validating Proxy IP to connect on ONION Network... ", end='')
        proxies = self.proxy_parser(proxy)
        try:
            check = requests.get('https://check.torproject.org/', proxies=proxies)
            if check.status_code == 200:
                if re.findall(r'Congratulations. This browser is configured to use Tor.', check.text):
                    print("Finished!")
                    return True
                else:
                    print("Fail!")
                    print("\nCould not validate proxy address!")
                    self.docker.stop()
                    sys.exit(2)
            elif check.status_code == 503:
                print("Fail!")
                print("The circuit you are using is going through one or more overloaded nodes and so your client is not getting a response in time.\n")
                self.docker.stop()
                sys.exit(2)
        except OSError as e:
            print("Fail!\n")
            print("The circuit you are using is going through one or more overloaded nodes and so your client is not getting a response in time.\n")
            self.docker.stop()
            sys.exit(2)

    def get_leak(self, proxy, search, leaks_file):
        print("Seeking for leak... ", end='')
        proxies = self.proxy_parser(proxy)

        if re.search(self.regex, str(search)):
            self.data['luser'] = search.split('@')[0]
            self.data['domain'] = search.split('@')[1]
        else:
            self.data['domain'] = search
            self.data['domainopr'] = 1

        leaks = requests.post(self.url, headers=self.headers, proxies=proxies, data=self.data)

        if leaks.status_code == 200:
            print("Finished!")
            self.seek_4_leaks(leaks.text, leaks_file)
        else:
            print("Fail!")
            print("\nWe have one of the following problems:")
            print("    1. pwndb2 is down (most probable);")
            print("    2. There may be a problem with DNS resolution at the exit node you are using;")
            print("    3. The circuit you are using is going through one or more overloaded nodes and so your client is not getting a response in time.")
            print("\nAlternatively, may you want kill your proxy/privoxy to get another circuit and try to seek for leak again.\n")
            self.docker.stop()
            sys.exit(2)

    def get_pass(self, proxy, secret, leaks_file):
        print("Seeking for leak... ", end='')
        proxies = self.proxy_parser(proxy)
        self.data['submitform'] = 'pw'
        self.data['password'] = secret

        leaks = requests.post(self.url, headers=self.headers, proxies=proxies, data=self.data)
        print("Finished!")

        self.seek_4_leaks(leaks.text, leaks_file)

    def seek_4_leaks(self, leaks, leaks_file):

        if not leaks:
            return ''

        pwned = re.findall(r'\[(.*)', leaks)
        pwned = [ pwned[n:n+4] for n in range(0, len(pwned), 4) ]
        del pwned[0]
        getinfo = lambda s: s.split('=>')[1].strip()

        if leaks_file is not None and os.path.isfile(leaks_file):
            f = open(leaks_file, "a+")
            f.write("Leaks from pwndb: \n")
            for item in pwned:
                f.write('{}@{}'.format(getinfo(item[1]),getinfo(item[2]))+':'+getinfo(item[3])+"\n")
            f.close()
            print("You can access the results in "+leaks_file+".")
        else:
            if pwned:
                print("Leaks:")
                for item in pwned:
                    print('{}@{}'.format(getinfo(item[1]),getinfo(item[2]))+':'+getinfo(item[3]))
            else:
                print("Ooops no leaks!")
