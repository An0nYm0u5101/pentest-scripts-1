#############################################################
#                                                           #
# This file is an essential part of collector's execution!  #
# And is responsible to get the functions:                  #
#   * hosts_alive                                           #
#                                                           #
############################################################# 

hosts_alive(){
    if [ -d "${report_dir}" ]; then
        if [ -s "${report_dir}/domains_alive.txt" ]; then
            echo -ne "${yellow}$(date +%H:%M)${reset} ${red}>>${reset} Testing subdomains to know if it is or have web application... "

            if [ -n "${use_proxy}" ] && [ "${use_proxy}" == "yes" ]; then
                proxy_port=8118
                proxy_ports=$("${docker_bin}" ps -a | grep -E "privoxy.*0.0.0.0" | awk '{print $13}' | sed -e 's/-.*$//' | awk -F':' '{print $2}')

                while [[ "${proxy_ports[@]}" =~ "${proxy_port}" ]]; do
                    (( proxy_port+=1 ))
                done

                "${docker_bin}" run -d --rm --name "hosts_alive_detect" -p "${proxy_port}:8118" privoxy > /dev/null

                if [ "$(${docker_bin} ps -a | grep -E hosts_alive_detect | awk '{print $14}')" == "hosts_alive_detect" ]; then
                    proxy="$(docker inspect --format '{{ .NetworkSettings.IPAddress }}' "hosts_alive_detect"):${proxy_port}"
                fi
                [[ -n "${proxy}" ]] && alias curl="curl --proxy ${proxy}"
            fi

            for subdomain in $(cat "${report_dir}/domains_alive.txt"); do
                for port in "${web_port_detect[@]}"; do
                    if [[ "${port}" -eq 80 ]]; then
                        subdomain_url="http://${subdomain}"
                    elif [[ "${port}" -eq 443 ]]; then
                        subdomain_url="https://${subdomain}"
                    else
                        subdomain_url="http://${subdomain}:${port}"
                    fi
                    subdomain_status_check=$(curl "${curl_options[@]}" -w "%{response_code}\n" "${subdomain_url}" -o /dev/null 2>/dev/null)
                    if [[ "${subdomain_status_check}" -eq 400 ]] || [[ "${subdomain_status_check}" -eq 000 ]] \
                        && [[ "${subdomain_url}" =~ ^http:.*:"${port}" ]]; then
                        subdomain_url="https://${subdomain}:${port}"
                        subdomain_status_check=$(curl "${curl_options[@]}" -w "%{response_code}\n" "${subdomain_url}" -o /dev/null 2> /dev/null)
                    fi
                    while [[ ${web_status_redirect[*]} =~ ${subdomain_status_check} ]]; do
                        new_subdomain_url=$(curl "${curl_options[@]}" -I "${subdomain_url}" 2> /dev/null | grep -i "Location: " | awk '{print $2}' | sed -e 's/^\///' -e 's/\r//')
                        if [[ "${new_subdomain_url}" =~ ^http.* ]]; then
                            subdomain_url="${new_subdomain_url}"
                        else
                            if [[ "${subdomain_url}" =~ ^https:.* && ${port} -ne 443 ]]; then
                                subdomain_url="https://${subdomain}:${port}/${new_subdomain_url}"
                            elif [[ "${subdomain_url}" =~ ^https:.* && ${port} -eq 443 ]]; then
                                subdomain_url="https://${subdomain}/${new_subdomain_url}"
                            elif [[ "${subdomain_url}" =~ ^http:.* && ${port} -ne 80 ]]; then
                                subdomain_url="http://${subdomain}:${port}/${new_subdomain_url}"
                            elif [[ "${subdomain_url}" =~ ^http:.* && ${port} -eq 80 ]]; then
                                subdomain_url="http://${subdomain}/${new_subdomain_url}"
                            fi
                        fi
                        subdomain_status_check=$(curl "${curl_options[@]}" -w "%{response_code}\n" "${subdomain_url}" -o /dev/null 2>/dev/null)
                        if [[ "${subdomain_status_check}" -eq 400 ]] || [[ "${subdomain_status_check}" -eq 000 ]] \
                            && [[ "${subdomain_url}" =~ ^http:.*:${port} ]]; then
                            subdomain_url="https://${subdomain}:${port}"
                            subdomain_status_check=$(curl "${curl_options[@]}" -w "%{response_code}\n" "${subdomain_url}" -o /dev/null 2> /dev/null)
                        fi
                    done
                    if [[ ${web_status_detect[*]} =~ ${subdomain_status_check} ]]; then
                        echo "${subdomain_url}" \
                            | sed -e 's/\/\/$//' \
                            | sed -e 's/:443//' \
                            | sed -e 's/:80$//' \
                            | sed -e 's/\(:80\)\(\/\)/\2/' \
                            | sed -e 's/:\/$//' \
                            | sed -e 's/\(\.\)\([[:alpha:]]*\)\(\/$\)/\1\2/' \
                            | tr '\n' '\t' ; echo "${subdomain_status_check}" 
                    fi
                done
            done | sort -u >> "${report_dir}/domains_web_status.txt"
            
            for page_status in "${web_get_status[@]}"; do
                grep -E "${page_status}$" "${report_dir}/domains_web_status.txt" | awk '{print $1}' >> "${report_dir}/domains_web.txt"
            done

            if [ "$(${docker_bin} ps -a | grep -E hosts_alive_detect | awk '{print $14}')" == "hosts_alive_detect" ]; then
                unalias curl
                unset proxy
                unset proxy_port
                unset proxy_ports
                "${docker_bin}" stop "hosts_alive_detect" > /dev/null
            fi
            echo "Done!"

            if cp "${report_dir}/domains_alive.txt" "${report_dir}/domains_without_response.txt"; then
                echo -ne "${yellow}$(date +%H:%M)${reset} ${red}>>${reset} Separating infrastructure from web application... "
                while IFS= read -r line; do
                    subdomain=$(echo "${line}" | sed -e "s/http:\/\///" -e "s/https:\/\///" | awk -F":" '{print $1}' | awk -F"/" '{print $1}')
                    if grep "${subdomain}" "${report_dir}/domains_without_response.txt" > /dev/null 2>&1 ; then
                        sed -i "/^${subdomain}$/d" "${report_dir}/domains_without_response.txt"
                    else
                        continue
                    fi
                unset subdomain
                done < "${report_dir}/domains_web_status.txt"
                echo "Done!"
            fi
            
            if [ -s "${report_dir}/domains_web_status.txt" ] && [ -s "${report_dir}/domains_without_response.txt" ]; then
                echo -e "\t We have $(awk '{print $1}' "${report_dir}/domains_web_status.txt" | sed -e 's/^http.*\/\///' -e 's/:.*$//' | awk -F'/' '{print $1}' | sort -u | wc -l ) Web Applications URLs."
                echo -e "\t Probably we have $(wc -l "${report_dir}/domains_without_response.txt" | awk '{print $1}') Infrastructure domains."
            fi

        else
            echo -e "${yellow}$(date +%H:%M)${reset} ${red}>>${reset} hosts_alive function error: the ${report_dir}/domains_alive.txt does not exist or is empty."
            exit 1
        fi
    else
        echo -e "${yellow}$(date +%H:%M)${reset} ${red}>>${reset} Make sure the directories structure was created. Stopping the script."
        exit 1
    fi
}
